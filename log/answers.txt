--------------------------------------------------------------------------------
- oz problem:

Mozart Compiler 2.0.0-alpha.0+build.7.92e4df7 (Jan 15 2013 17:33:59) playing Oz 3

\insert '/home/rb/etudes/memoire/ParseAndAssemble.oz'

%************************* expansion error **********************
%**
%** illegal use of nesting marker
%**
%** in file "/home/rb/etudes/memoire/ParseAndAssemble.oz", line 1, column 7
%** ------------------ rejected (1 error)


A: C'est normal, en fait. Le feed buffer attend un Statement, alors que tu lui donnes une Expression.

Si tu veux "feeder un functor", fais ceci :
local
   F =
   \insert '/home/rb/etudes/memoire/ParseAndAssemble.oz'
   [M] = {Module.apply [F]}
in
   {Wait M}
end

--------------------------------------------------------------------------------

- les parametres formels sont-ils dans des X ou des Y? Quelle est mon erreur ci-dessous?
  Dans le code qu'on a discuté, ils se trouvent dans des Y:
  {Foo A B C }
  move( y(0) x(0) )   <= copy first argument in X register 0 to make it available to call

  Par contre d'apres le code dans CodeGen.scala (method applyToAbstraction), ils sont initialement disponibles dans des X:
    // Save formals in local variables
    for ((formal, index) <- abstraction.formals.zipWithIndex)
      code += OpMove(XReg(index), formal.toReg.asInstanceOf[XOrYReg])

A: Initialement, ils sont en effet dans les X de 0 à N-1, où N est le nombre de paramètres de la procédure. CodeGen.scala commence par les recopier dans des Y pour qu'ils soient conservés tout au long de la procédure.

--------------------------------------------------------------------------------
-  ceci fonctionne:
     case R of l(F1 F2 F3) then
   mais pas ceci. Correct?
        case R of MatchedLabel(F1 F2 F3) then
A: Correct

--------------------------------------------------------------------------------
- j'essaie d'utiliser l'inspector, mais ca ne marche pas:
   Could not load functor at URL: x-oz://system/Inspector.ozf
A: not yet in Mozart2

--------------------------------------------------------------------------------
- {Show AST} affiche certains records avec les fields etant ..., par ex 'fVar'('B' 'pos'(...)). Il y a moyen d'eviter ca?
A: Use DumpAST

--------------------------------------------------------------------------------
- ou est definie StatAndExpression ? 
A: Dans ast/Expressions.scala . C'est une case class, qui permet du pattern matching. http://www.scala-lang.org/node/107

--------------------------------------------------------------------------------
- ou est definie la classe Product? 
A : c'est une class de la stdlib, représentant un produit cartesien.

--------------------------------------------------------------------------------
- Dans CommonStatExpr, qu'est LocalCommon ?
A: C'est ce qui est hérité par RawLocalStatement, LocalStatement, RawLocalExpression et LocalExpression 

--------------------------------------------------------------------------------
- Que fait ce code dans OpCode.scala? 
  def code = {
    (name /: arguments) {
      (prev, arg) => prev + ", " + arg.code
    }
  }
A: foldleft.

- eclipse config
ok

- Dans le functor DumpAST.oz j'ai mis un skip. Quelle est la bonne facon de faire?
A: ne pas mettre le in

- Pourquoi DumpAST utilisé dans Parse.oz donne une liste? Plusieurs locals sont placés dans fAnd()
A: le parser renvoie une liste de compilation unit. Pour le moment, considerer 1 element (phrase) voir compiler node 7

- comment utiliser le parser dans un programme interactif oz (eg avec declare). Pour le moment j'ai pris le dump, rajouté les '' où il fallait pour avoir l'AST dans mon script.
A: prendre le premier element de la liste

-http://www.mozart-oz.org/documentation/notation/node6.html#label22 je comprends pas le X=E et ensuite  proc {X ...}.
A: E peut en pratique etre une variable ou le $. 

- Implémenter Proc pour implémenter fun.

- pourquoi Node extends Product?
A: scala, pas important

- ou est le contstructeur de Node (et de StatOrExpr, ProcFunExpression, ....) ?
A: implicite, arguments dans la declaration, et code est le corps de la classe.

- Dans LocalStatement (et Raw/Expression), les déclarations sont abandonnées?
A:  dans une case class, tous les parametres sont directement un champs de la classe

- Dans le namer on a
    case local @ RawLocalStatement(declarations, body) =>
      val (decls, stats) = extractDecls(declarations)
      val stat = statsAndStatToStat(stats, body)

      withEnvironmentFromDecls(decls) {
        if (decls.isEmpty) transformStat(stat)
        else treeCopy.LocalStatement(local, decls, transformStat(stat))
      }
   ? syntaxe local @ RawLocalStatement : reference à l'entiereté de l'argument, typé
   ? premier argument passé à treeCopy.LocalStatement = ?


- Pourquoi treecopier crée de nouveaux noeuds meme quand rien n'a changé?
A: parce qu'il est bete
- Une feature ne peut etre initialisée dans init()? Si, faire self.feature!
declare
class A
   feat
      f
   meth init()
      self.f=test
   end
end

V={New A init}
{Show V.f} 

- si on remplace les fVar par des fSym pour les locales, peut-on en conclure que quand on rencontre un fVar dans le codegen, il s'agit forcément d'une globale?
A: non, toutes les vars doivent etre remplacée par des sym. Au sommet, il y a la top level abstraction, et eventuellement l'environnement de base.

- ou est definie la top abstrction dans scala?
A: dans symtab/Program.scala


- decls flattener: si LHS est une expression, appeller PV

- pour déterminer si on a une expression ou un statement, partir du haut.
expressions et statement subiront souvent des transformations différentes -> distinguer au niveau des fonctions appellées aussi.

- le namer peut-il se contenter de parcourir les declarations pour l'assignation de symbole au variable si ceci se fait apres la 'normalisation' (cad qd "local in" ne contient que des declaration).
oui

- meme question pour l'assignement des Y registers
oui

-gencode ne comprends que des statements élémentaires. par ex scala a que generate (statement)

- http://www.mozart-oz.org/documentation/notation/node6.html : 
  PV: difference entre expression et statement? 
  E = ... -> PV(E)
  E1=E2 => PV1 + PV2

  est-ce que PV est à utiliser dans des cas comme 
   local
      X|Xr=L
   in
  mais pas dans
   local
     B={Compute blabla}
   in
  ?

- discussion sur les listes. Cf gencode qui a besoin d'un flatten
   {Append [1 2] 3|4 }    => 1|2|3|4     == brol
   {Append [1 2] 3|4|nil} => 1|2|3|4|nil

