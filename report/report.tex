%http://vim-latex.sourceforge.net/documentation/latex-suite.html#environment-mappings
\documentclass[draft,a4paper]{memoir}
\usepackage[utf8]{inputenc}
\usepackage{pgf}
\usepackage[margin=false,inline=true]{fixme}
\fxsetup{theme=color}
\definecolor{fxnote}{rgb}{0.8000,0.0000,0.0000}
\author{Bauduin RaphaÃ«l}
\title{Oz Compiler}
\begin{document}

% requires memoir
% include git rev
\ifdraftdoc
\makeoddhead{plain}{}{}{\textit{Draft: \today{} Rev: \GITAbrHash{} \VCModifiedText{}}}{}
\fi

% write and require version control info
\immediate\write18{sh ./vc -m} 
\input{vc}
\maketitle
\tableofcontents


\chapter{Introduction}
\section{Initial State}
New vm developed.
Old compiler patched, boot compiler in scala.
Need for a new Oz compiler, written in OZ

\section{Goal and Scope}
Flexible documented and tested compiler taking as input the AST in the form of Oz records, and generating opcodes send to the assembler.
Document as much as possible the whole compilation chain from parser through AST to opcodes and virtual machine.

\chapter{Infrastructure}
\section{Virtual Machine}
Describe virtual machine. I think to put it first so all concepts are introduced by the time I describe the opcodes.
\subsection{Registers}
Y are locals(y(index)), X are work registers (x(index)), G are globals filled sequentially with arrayFill (g(index)), k are constants (k(value))
\subsection{Abstractions}
Abstraction (with G regs)  -> CodeArea (with K regs) -> Code
\section{Compiler input}
Describe records received from parser.
fInt,fFloat,fVar, fEq, fProc\ldots
\section{Compiler output}
Describe opcodes.


\chapter{Compiler}
\section{Architecture}
Explain the phases
\subsection{Namer}
replaces fVar by fSym. In declarations, creates a new symbol for declared variables, in body, looks at already defined symbols.
fLocal introduces a new environment, in which the variables declared in its first feature are added to the environment, possibly erasing variables with the same name coming from the parent environment.
It is this manipulation of the environments that make that the code here 1) does not throws an error of impossible unification and 2)shows 6.
local
   A=5
in
   local 
      A=6
   in
      {Show A}
   end
end

\subsection{Globaliser}            
This pass handles the global variables. It is interesting to note that the concept of global variables is only defined for procedures.
Just as locals attached an environment to their body, procedures attach their own unique procId to their arguments, declarations and body.
Variables declared by a procedure, including formal parameters, get assigned the procId of said procedure.

When a variable is used in a procedure other than its declaring procedure, it is a global variable for said procedure. We replace this symbol by new symbol marked as 'global' referencing the original symbol.

Special attention has to be paid to nested procedure declarations. For example
A=1
proc {P1}                 % A is global
   B=2
   P2
in
   proc {P2}              % A and B are globals
      P3 
   in
      proc {P3}           % A and B are globals
         C
      in
         {Show A}
         {Show B}
         {Show C}
      end
      {P3}
   end
   {P2}
end

The globals of procedures in the code have to be determined from the inside to the outside: determine the globals of the deepest nested procedure, and go up. 
We see that the globals of a procedure are:
\begin{itemize}
  \item variables it uses (i.e. not in a procedure definition) that were defined in a parent procedure
  \item the globals of all the procedures it defines
  \item minus the variables it declares
\end{itemize}
In the example we see that P3 uses 2 variables declared by another procedure: A and B. 
P2 does not directly use any variable, but it defines P3 which itself has 2 global variables. Those two variables are thus also globals to P2
P1 also does not use any variable directly, but it gets 2 globals from P2, of which it declares one: B. P1 indeed only has one global: A.

In the abstract syntax tree, fProc is replaced by fDefineProc taking 2 additional arguments: the global variables and their corresponding new symbols. This additional information will enable the code generator handle global variables. \fxnote{Check that the two arguments are really needed}
\subsection{CodeGen}
\subsubsection{Register allocation}
It is CodeGen that allocates registers. For the moment only Y registers.
When a Symbol of type global is found, it is handled differntly than local symbols.
For a procedure definition, we initialise the global variables with arrayFill( y(yindex)). \fxnote{handle multiple levels of nesting}
For a local\ldots in \ldots end, a g() is issued in place of a y(). \fxnote{is this working yet?}

\section{Tests}
Explain the tests

\section{Performance}
Possibly include some measure?



\end{document}
