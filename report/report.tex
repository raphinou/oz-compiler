%http://vim-latex.sourceforge.net/documentation/latex-suite.html#environment-mappings
\documentclass[draft,a4paper]{memoir}
\usepackage[utf8]{inputenc}
\usepackage{pgf}
\usepackage[margin=false,inline=true]{fixme}
\fxsetup{theme=color}
\definecolor{fxnote}{rgb}{0.8000,0.0000,0.0000}
\author{Bauduin RaphaÃ«l}
\title{Oz Compiler}
\begin{document}

% requires memoir
% include git rev
\ifdraftdoc
\makeoddhead{plain}{}{}{\textit{Draft: \today{} Rev: \GITAbrHash{} \VCModifiedText{}}}{}
\fi

% write and require version control info
\immediate\write18{sh ./vc -m} 
\input{vc}
\maketitle
\tableofcontents


\chapter{Introduction}
\section{Initial State}
New vm developed.
Old compiler patched, boot compiler in scala.
Need for a new Oz compiler, written in OZ

\section{Goal and Scope}
Flexible documented and tested compiler taking as input the AST in the form of Oz records, and generating opcodes send to the assembler.
Document as much as possible the whole compilation chain from parser through AST to opcodes and virtual machine.

\chapter{Infrastructure}
\section{Virtual Machine}
Describe virtual machine. I think to put it first so all concepts are introduced by the time I describe the opcodes.
\subsection{Registers}
Y are locals(y(index)), X are work registers (x(index)), G are globals filled sequentially with arrayFill (g(index)), k are constants (k(value))
\subsection{Abstractions}
Abstraction (with G regs)  -> CodeArea (with K regs) -> Code
\section{Compiler input}
Describe records received from parser.
fInt,fFloat,fVar, fEq, fProc\ldots
\section{Compiler output}
Describe opcodes.


\chapter{Compiler}
\section{Architecture}
Explain the phases
\subsection{Namer}
replaces fVar by fSym. In declarations, creates a new symbol for declared variables, in body, looks at already defined symbols.
fLocal introduces a new environment, in which the variables declared in its first feature are added to the environment, possibly erasing variables with the same name coming from the parent environment.
It is this manipulation of the environments that make that the code here 1) does not throws an error of impossible unification and 2)shows 6.
local
   A=5
in
   local 
      A=6
   in
      {Show A}
   end
end

\subsection{Globaliser}            
This pass handles the global variables. It is interesting to note that the concept of global variables is only defined for procedures.
Just as locals attached an environment to their body, procedures attach their own unique procId to their arguments, declarations and body.
Variables declared by a procedure, including formal parameters, get assigned the procId of said procedure.

When a variable is used in a procedure other than its declaring procedure, it is a global variable for said procedure. We replace this symbol by new symbol marked as 'global' referencing the original symbol.

Special attention has to be paid to nested procedure declarations. For example
A=1
proc {P1}                 % A is global
   B=2
   P2
in
   proc {P2}              % A and B are globals
      P3 
   in
      proc {P3}           % A and B are globals
         C
      in
         {Show A}
         {Show B}
         {Show C}
      end
      {P3}
   end
   {P2}
end

The globals of procedures in the code have to be determined from the inside to the outside: determine the globals of the deepest nested procedure, and go up. 
We see that the globals of a procedure are:
\begin{itemize}
  \item variables it uses (i.e. not in a procedure definition) that were defined in a parent procedure
  \item the globals of all the procedures it defines
  \item minus the variables it declares
\end{itemize}
In the example we see that P3 uses 2 variables declared by another procedure: A and B. 
P2 does not directly use any variable, but it defines P3 which itself has 2 global variables. Those two variables are thus also globals to P2
P1 also does not use any variable directly, but it gets 2 globals from P2, of which it declares one: B. P1 indeed only has one global: A.

In the abstract syntax tree, fProc is replaced by fDefineProc taking 1 additional argument: the newly created local variables referencing a variables in the surrounding procedure. This additional information will enable the code generator handle global variables.

Variables declared by a proc P1 and used by a procedure P2 is also defines are globals for P1 and local to P1. So P1 does not have to create a new local. This is done in the code simply by looking  which procId each new locals of P2 references. If it references P1's procId, it does nothing as this means it references a variable declared by P1 itself.

Handling globals is tricky, as illustrated by these examples:

local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
end
In this case, A is global for P3 and it created a new local referencing a variable in P2. But for P2, A is also global, and this needs to trigger a new local creation in P2, which will be referenced by the new local in P3. Same thing in P1.

local
   A
in
   proc {P1}
      P2
   in
      {Show A}  % Use A before a defined procedure needs it
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
end

In this case, the traversal of the AST will first analyse {Show A} and later on the procedures P2 and P3. In this case, P2 will create a new local that will reference a variable in P2, which is also a new local as A os global to P1. But this new local does not have to be created as it already has been created when {Show A} was traversed.

Of course, the inverse has to be handled too, ie a new local is created for a defined proc, and reused later

local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
   {Show A}  % Use A after a nested proc triggered the creation of a new local.
end



Two procs defined at the same level have to reference the same variable (new local or declared variable of the outer proc). In this example, A is referenced by a new local in P1, which itself has to be referenced from new locals in P2 and P3.

local
   A
in
   proc {P1}
      P2 P3
   in
      proc {P2}
         {Show A}
      end
      proc {P3}
          {Show A}
      end
      {P2}
      {P3}
   end
   {Show A}  % Use A after a nested proc triggered the creation of a new local.
end

\subsection{CodeGen}
\subsubsection{Register allocation}
It is CodeGen that allocates registers. For the moment only Y registers.
When a Symbol of type global is found, it is handled differntly than local symbols.
For a procedure definition, we initialise the global variables with arrayFill( y(yindex)). \fxnote{handle multiple levels of nesting}
For a local\ldots in \ldots end, a g() is issued in place of a y(). \fxnote{is this working yet?}

\section{Tests}
Explain the tests

\section{Performance}
Possibly include some measure?



\end{document}
