%http://vim-latex.sourceforge.net/documentation/latex-suite.html#environment-mappings
\documentclass[draft,a4paper]{memoir}
\usepackage[utf8]{inputenc}
\usepackage{pgf}
\usepackage[margin=false,inline=true]{fixme}
\fxsetup{theme=color}
\definecolor{fxnote}{rgb}{0.8000,0.0000,0.0000}
\author{Bauduin RaphaÃ«l}
\title{Oz Compiler}
\begin{document}

% requires memoir
% include git rev
\ifdraftdoc
\makeoddhead{plain}{}{}{\textit{Draft: \today{} Rev: \GITAbrHash{} \VCModifiedText{}}}{}
\fi

% write and require version control info
\immediate\write18{sh ./vc -m} 
\input{vc}
\maketitle
\tableofcontents


\chapter{Introduction}
\section{Initial State}
New vm developed.
Old compiler patched, boot compiler in scala.
Need for a new Oz compiler, written in OZ

\section{Goal and Scope}
Flexible documented and tested compiler taking as input the AST in the form of Oz records, and generating opcodes send to the assembler.
Document as much as possible the whole compilation chain from parser through AST to opcodes and virtual machine.

\chapter{Infrastructure}
\section{Virtual Machine}
Describe virtual machine. I think to put it first so all concepts are introduced by the time I describe the opcodes.
\subsection{Registers}
Y are locals(y(index)), X are work registers (x(index)), G are globals filled sequentially with arrayFill (g(index)), k are constants (k(value))
\subsection{Abstractions}
Abstraction (with G regs)  -> CodeArea (with K regs) -> Code
\section{Compiler input}
Describe records received from parser.
fInt,fFloat,fVar, fEq, fProc\ldots
\section{Compiler output}
Describe opcodes.


\chapter{Compiler}
\section{Architecture}
Explain the phases
\subsection{Namer}
replaces fVar by fSym. In declarations, creates a new symbol for declared variables, in body, looks at already defined symbols.
fLocal introduces a new environment, in which the variables declared in its first feature are added to the environment, possibly erasing variables with the same name coming from the parent environment.
It is this manipulation of the environments that make that the code here 1) does not throws an error of impossible unification and 2)shows 6.
local
   A=5
in
   local 
      A=6
   in
      {Show A}
   end
end

\subsection{Globaliser}            
This pass handles the global variables of a procedure, that is, variables used by a procedure that does not declare it (implying that the declaration is done at un upper level. It is interesting to note that the concept of global variables is only defined for procedures.
Just as locals attached an environment to their body, procedures attach their own unique procId to their arguments, declarations and body.
Variables declared by a procedure, including formal parameters, get assigned the procId of said procedure.

Special attention has to be paid to nested procedure declarations. For example
A=1
proc {P1}                 % A is global to P1
   B=2
   P2
in
   proc {P2}              % A and B are globals to P2
      P3 
   in
      proc {P3}           % A and B are globals to P3
         C
      in
         {Show A}
         {Show B}
         {Show C}
      end
      {P3}
   end
   {P2}
end

The globals of procedures in the code have to be determined from the inside to the outside: determine the globals of the deepest nested procedure, and go up. 
We see that the globals of a procedure are:
\begin{itemize}
  \item all variables it uses directly (i.e. not in a procedure definition)
  \item plus the globals of all the procedures it defines
  \item minus the variables it declares itself
\end{itemize}

In the example we see that P3 uses 2 variables declared by another procedure: A and B. 
P2 does not directly use any variable, but it defines P3 which itself has 2 global variables. Those two variables are thus also globals to P2
P1 also does not use any variable directly, but it gets 2 globals from P2, of which it declares one: B. P1 indeed only has one global: A.

In the abstract syntax tree, we replace symbols corresponding to a global variables by a new local symbol of type 'newlocal' referencing the symbol for this variables in the parent proc which might itself be a 'newlocal' symbol, and so on until we reach the level where the variables is declared.

In the abstract syntax tree, fProc is replaced by fDefineProc taking 1 additional argument: the newly created local variables referencing a variables in the surrounding procedure. This additional information will enable the code generator handle global variables.

Handling globals correctly requires to handle numerous cases, and determining the algorithm to use requires some care, as illustrated by these examples:

local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
end
In this case, A is global to P3 and it creates a new local symbol that will reference a symbol local to P2. But for P2, A is also global, and this situation needs to trigger a new local creation in P2, which will be referenced by the new local in P3. Same thing in P1.

local
   A
in
   proc {P1}
      P2
   in
      {Show A}  % Use A before a defined procedure needs it
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
end

In this case, the traversal of the AST will first analyse {Show A} and create a new local symbol for the variables A in P1. P2 is cisited later and will create a new local to reference a symbol local to P2, which is also a new local as A is global to P1. But this new local has already been created, and this situation must not trigger the creation of a new local symbol for A. Rather, the new local symbol to P2 must reference the new local symbol to P1. We see that the new local variables created in a procedure definition may have to be modified by its parent procedure.

Of course, the inverse has to be handled too, ie a new local is created for a defined proc, and reused later:

local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
      {Show A}  % Use A after a nested proc triggered the creation of a new local.
   end
end


Of course, a new local symbol must not be created when it would represent a locally declared variables, as in this case:

local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
   {Show A}  % A is defined locally, and the nested procs defined should not trigger the creation of a new local, but P1's new local for A should reference the A declared by the local .. in .. end
end

Two procs defined at the same level must have have their respective new local symbols reference the same symbol at the parent level (whether it be a new local symbol created at the parent level or the existing symbol of a declared variable at the parent level). In this example, P2 and P3 each create a new local for A and both trigger the creation of a new local in P1 for A. But only one new local should be created in P1 for A, and both locals in P2 and P3 should reference it.


Example V:
local
   A
in
   proc {P1}
      P2 P3
   in
      proc {P2}
         {Show A}
      end
      proc {P3}
          {Show A}
      end
      {P2}
      {P3}
   end
   {Show A}  % Use A after a nested proc triggered the creation of a new local.
end

In the end, the algorithm used is the following.
Each call of the globaliser takes the AST subtree and an additional Params argument with three fields:
\begin{itemize}
   \item the current procId
   \item a list of global variables already seen in the current procId
   \item a list, each item being the list of new local symbols created for the global with same index in the previous list.
\end{itemize}

The globalise handles the following nodes:
\begin{description}
   \item[fProc] When handling a fProc, the globaliser call gets the informations from the parent in its Params argument. Because we enter a new level of procedure nesting, a NewParams is initialised to be passed to recursive globaliser calls handling children nodes. NewParams is initialised with a new procId and two empty lists. 
      The symbol of the procedure itself gets the procId of its parent, found in Params. The arguments of the procedure get the procId of the currently handled procedure, found in NewParams. At that time the globaliser function is called resursively on the children nodes, with NewParams as additional argument.
      Once all children have been traversed, the list of their globals and their respective newly created locals is found in NewParams.  We have multiple new locals corresponding to one global in the case of 2 siblings procedure definitions refering the same global as in example V. 
      Globals whose procId match the NewParams' procId are ignored, as those are variables that are declared at this level, and the chain of references must stop here for these variables.
      For each remaining global, we look at the list of their locals. 
      If one of these has the procId matching the current level, all other locals are changed to reference this one. This is because this specific symbol has been created by a direct use at this level, and we will use this one as the new localised symbol at this level. Then we push the global on the parent's globals list and add the local symbol to its corresponding list of new locals (those lists are found in Params)
      If none of the locals has the current level's procId, it means the global variables has only been used in nested procedure definitions. We need to create a new local symbol for that variable at the current level that will be referenced by the existing locals. Finally, we push the global and the new local symbol we created to the parent. 
   \item[fSym] If the symbol in this fSym has the current procId found in NewParams, keep it as is, do not change it! 
      If its procId is different from the current procId, this fSym represents a global variable for the current level. We look in Params if a loca variable with the current procId has already been created for this global variable. If yes we reuse it, else We define a new symbol, having the curren tprocId and referencing the symbol initially in fSym. We modify the fSym to use that newly created symbol. Finally, push the global and its local to the parent.
      
\end{description}



\subsection{CodeGen}
\subsubsection{Register allocation}
It is CodeGen that allocates registers. For the moment only Y registers.
When a Symbol of type global is found, it is handled differntly than local symbols.
For a procedure definition, we initialise the global variables with arrayFill( y(yindex)). \fxnote{handle multiple levels of nesting}
For a local\ldots in \ldots end, a g() is issued in place of a y(). \fxnote{is this working yet?}

\section{Tests}
Explain the tests

\section{Performance}
Possibly include some measure?



\end{document}
