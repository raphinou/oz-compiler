%http://vim-latex.sourceforge.net/documentation/latex-suite.html#environment-mappings
%http://www.latextemplates.com/template/masters-doctoral-thesis
\documentclass[a4paper]{memoir}
\usepackage[utf8]{inputenc}
\usepackage{pgf}
\usepackage[margin=false,inline=true]{fixme}
\usepackage{listings} % DO NOT USE DRAFT DOCUMENT AS IT WILL NOT DISPLAY THE CODE
\setcounter{secnumdepth}{3} 


\fxsetup{theme=color}
\definecolor{fxnote}{rgb}{0.8000,0.0000,0.0000}
\author{Bauduin RaphaÃ«l}
\title{Oz Compiler}
\begin{document}
% configure listings package to handle code as Oz code
\lstset{language=Oz}


% requires memoir
% include git rev
\ifdraftdoc
\makeoddhead{plain}{}{}{\textit{Draft: \today{} Rev: \GITAbrHash{} \VCModifiedText{}}}{}
\fi

% write and require version control info
\immediate\write18{sh ./vc -m} 
\input{vc}
\maketitle
\tableofcontents


\chapter{Introduction}
\section{Initial State}
New vm developed.
Old compiler patched, boot compiler in scala.
Need for a new Oz compiler, written in OZ

\section{Goal and Scope}
The compiler takes as input the AST in the form of Oz records, and generates opcodes sent to the assembler. 
There were four goals set for the compiler:
\begin{enumerate}
  \item compile the whole language so that it can replace the current compiler in Mozart 2
  \item generate quality code, exploiting the capabilities of the virtual machine
  \item easy to understand and modular code
  \item the compiler should also be extensible so that, for example, support for a new instruction can be added without the recompilation of the compiler.
\end{enumerate}
Although the code is extensively commented, this report contributes to the third goal.

\chapter{Infrastructure}
\section{Virtual Machine}
The Mozart2 virtual machine was developed from scratch, with extensive additional support for the Oz language's concepts compared to the Mozart1 virtual machine. As a consequence, the code to be generated by the compiler should use these new capabilities and be different in some cases from the code generated by the Mozart1 compiler.


\subsection{Registers}\label{sec:intro:registers}
The Mozart2 virtual machine works with four types of registers. The description of the registers uses the concept of abstractions, which is precisely defined in the next section. It is however sufficient for the understanding of this section to equate the concept of abstraction with the concept of procedure.
\begin{description}
  \item[X registers]are work registers that should not be used to permanently store values. X registers are for example used to pass the aguments to calls. However, the values in these registers are lost after the call. %FIXME: isn't it X regs might be lost?
    %FIXME: combien de registres X disponibles,alloues?
  \item[Y registers]are locally persisting registers. They all have to be initialised at once at the start of an abstraction's code, before their use, which requires to know how many Y registers are needed.
  \item[G registers] are holding global variables, i.e. variables that are accessed by the abstraction, but that are not locally declared.
  \item[K registers] are holding constant values, be it integers, floats or records.
\end{description}

Y are locals(y(index)), X are work registers (x(index)), G are globals filled sequentially with arrayFill (g(index)), k are constants (k(value))
\subsection{Abstractions}\label{sec:vm:abstractions}
An Oz procedure is represented in the virtual machine by what is called an abstraction. An Oz program itself is implicitely placed in what is called a top level abstraction.
An abstraction holds references to G registers and to its code area. This code area has references to its K registers and the code itself. 
\begin{verbatim}
+-----------+
|Abstraction|
|-----------|             +--------+
| CodeArea  |------------>|CodeArea|
| G0        |             |--------|
| G1        |             | Code   |------->ByteCode
| .         |             | K0     |
| .         |             | K1     |
| Gn        |             | .      |
+-----------+             | .      |
                          | Kn     |
                          +--------+
\end{verbatim}

Capturing the global variables at the abstraction level is what provides
closures: a procedure captures the environment it was defined in.
The CodeArea is not stored in the abstraction itself, but is referenced from
it, simply because the same CodeArea can be referenced from multiple
abstractions. Let's illustrate this by an example. 

% reference: http://www.info.ucl.ac.be/~pvr/bookfigures/fig3_8.oz

\begin{lstlisting}
   fun {Sqrt X}
      fun {Improve Guess}
        (Guess + X/Guess) / 2.0
      end
      fun {GoodEnough Guess}
        {Abs X-Guess*Guess}/X < 0.00001
      end
      fun {SqrtIter Guess}
         if {GoodEnough Guess} then Guess
         else
            {SqrtIter {Improve Guess}}
         end
      end
      Guess=1.0
   in
      {SqrtIter Guess}
   end
\end{lstlisting}
The method Sqrt computes the square root by Newton's method. Each time Sqrt is
called, it defines three local functions. The two first reference the variable
X, which is a global variable for them, and which has probably a different
value at each call of Sqrt. However, the code area for each function is the
same for every call of Sqrt, and the virtual machine can simply create a new
abstraction with one global variable referencing the already existing code
area. 

If we have 2 simultaneaous calls to Sqrt, for example {Sqrt 2} and {Sqrt 5}, we
would end up with this structure in the virtual machine:

\begin{verbatim}
Abstr1
CodeArea -------> CodeArea
G0=2          /   Code     -------------> Code
             /    K(2)                     with X registers
Abstr2      /
CodeArea --+
G0=5
\end{verbatim}



Abstraction (with G regs)  -> CodeArea (with K regs) -> Code
\section{Target Language}
The compiler will have to generate code that can be passed to the assembler targetting the virtual machine. This assembler language has solid support for the virtual machine concepts as we'll see.
The assembler accepts an Oz list of instructions that are Oz records. 

\subsection{Register Operations}\label{sec:intro:opcode:registers}
Registers access instructions are proper to each type. To access the nth G X Y registers, the instruction will respectively be g(n), x(n), y(n). 

K registers are used to store constants, and are not numbered, but identified by the value they store. The constant 2 will appear in the code as k(2), the constant record r(a b c) will appear in the code as k(r(a b c)).

As mentioned earlier, Y registers are persisting for the lifespan of the current frame. Their number has to be determined when the frame is initialised, and all needed Y registers are initialised at once with the instruction \lstinline!allocateY(n)! where n is the number of Y registers used in this frame.

X registers are work registers, and if a value in a X register needs to be accessed several time across calls, it has to be saved in a Y register. This is done with a move instruction: \lstinline!move(source_reg destination_reg)!.

%FIXME: what kind of registers can be unified. Does it make sense to unify X regs?
Unification is supported with the instruction unify(LHS RHS) where both LHS and RHS are registers.

\subsection{Jumps}\label{sec:opcode:jumps}
Code positions can be identified by labels, which need to be atoms or names. A label \lstinline!L! will appear in the code in a record \lstinline!lbl(L)!. 
Labels are required for jumps in the code. 
Jumps will move the execution to the label they have as argument. For example \lstinline!branch(endLabel)! will jump to the position in the code identified by the label \lstinline!endLabel!.

Conditional jumps will look at the value in a register, and if this value is not true, it will jump to the code at the label it was given. That instruction also takes a label locating error handling code. Here is an example of conditional jump that will look at the value in X register 0: \lstinline!condBranch(x(0) elseLabel errorLabel)|!. If the value in x(0) is true, it continues execution. If it is false it jumps to the position in the code identified by the label \lstinline!elseLabel!. If an error occurs, it jumps to the label \lstinline!errorLabel!.


\subsection{Calls}\label{sec:opcode:calls}
%FIXME: can only call procedures and builtins?
Calls can be made with \lstinline!call(R Args)!, where R is a register identifying what to call (procedure or builtin) and Args is the number of arguments passed to the callee. The arguments of the call are not directly passed to the call instruction, but have to be placed in the X registers from 0 to Args-1 with move instructions before the call, as this is where the virtual machine will look for the arguments. The complete code for a call to a callee located in register Y 3 with three arguments which values come from Y registers 0 to 2 will thus be of the form:
\begin{lstlisting}
move(y(0) x(0))
move(y(1) x(1))
move(y(2) x(2))
call(y(3) 3)
\end{lstlisting}

A call done as last instruction of an abstraction should be made with the tailCall instruction, as this lets the virtual machine optimise the execution. It has the exact same specification as the call instruction, only the name of the instruction differs: \lstinline!tailCall(Callee Args)!.

\subsection{Records}\label{sec:opcode:records}
Records, tuples and cons are directly supported by the virtual machine, handling each of these particularly to ensure performance and efficiency.
A record of arity Arity, with NumberOfFeatures features is unified with register DestinationReg with this instruction:
\lstinline!createRecordUnify(k(Arity) NumberOfFeatures DestinationReg)!. which has to be followed by instructions to fill the features with their respective values:
\lstinline!arrayFill(Reg)! where Reg is the register corresponding to the feature's value.
The arity is supported by the virtual machine and includes the label and features without their respective values.

There are two special cases of records that are handled specifically by the virtual machine.
A con is a record with label '|' and with only 2 features numbers 1 and 2 and is initialised by
\lstinline!createConsUnify(DestinationReg)!. Again, this instruction has to be followed by arrayFill instructions, two in this particular case.
A tuple is a record with all numeric features. It is initialised by \lstinline!createTupleUnify(k(Label) NumberOfFeatures DestinationReg)! and followed by arrayFill instructions.
\subsection{Procedures}\label{sec:opcode:procedures}
A procedure is represented by what is called an abstractions (see Section \ref{sec:vm:abstractions}), which is created and stored in register DestinationReg with
\lstinline!createAbstractionUnify(k(CodeArea) GlobalsCount  DestinationReg)!
CodeArea is the assembled body of the procedure (see Section \ref{sec:codegen:procedures} for details). GlobalsCount identifies how many references to global variables this abstraction holds. It is the number of arrayFill instructions that will follow to initialise those global variables that the abstraction can access in G variables numbered from 0. The first arrayFill instruction will set the value of g(0), the second the value of g(1), \ldots

Here is code we will analyse:

\begin{lstlisting}
local
  A B P
in
  A=1           % in register X 0
  B=2           % in register X 1
  proc {P}      % in register Y 0
    {Show A+B}  % A and B are globals for P
  end           % access in g(0) and g(1) resp.
end
\end{lstlisting}

As noted in the code comments, we suppose, the compiler having done its work of registers assignation, variables A and B are stored in registers X 0 and 1 respectively, that the abstraction for procedure P is to be stored in register Y 0, and that P accesses to the value A and B via the register g(0) and g(1) respectively.
The body having been assembled and stored in the constant value CodeArea, this will lead to this code passed to the assembler:
\begin{lstlisting}
createAbstractionUnify(k(CodeArea) 2  y(0))
arrayFill(x(0))
arrayFill(x(1))
\end{lstlisting}



\section{Compiler input}\label{section:compilerinput}
Describe records received from parser.
Not all will be described here as an exhaustive list is available at %http://www.mozart-oz.org/home/doc/compiler/node7.html#appendix.syntax. 
\subsection{Position in source code}
Most records have the corresponding position in the source code available in their last feature, encoded in a record of the form \lstinline!pos(File Linebegin Columnbegin Fileend Lineend Columnend)!. This information has to trickle through all transformations so meaningful error messages can be given to the programmer in case of error.

For clarity and brievety, in the examples of AST included in this document, the positions will always be represented by the featureless record \lstinline!pos!. 
\subsection{Basic data types}
The basic data type described in this section are the simplest node found in the AST as they have no children and are the leafs of the tree.
These are the types that are currently handled, with their corresponding records in the AST:
\begin{description}
  \item[integers] fInt(Val Pos)
  \item[floats] fFloat(Val Pos)
  \item[atoms] fAtom(value position)
\end{description}

\subsection{Variables}\label{sec:input:variables}
A variable is found in a record fVar(VarName Pos)

\subsection{Unification}
A unification is found in a record fEq(LHS RHS Pos).
A=3 gives fEq(fVar(A \_) fInt(3 \_))

\subsection{Instructions sequence}
A sequence of instructions is wrapped in fAnd records, the first feature being usually one instruction, the second feature being a fAnd if more than one instruction follows,  or a single instruction. The code also handles the case when the two features are fAnd records. %FIXME: is this needed? 
Example:\\
\begin{tabular}{ p{0.3\textwidth} p{0.8\textwidth} }
  \begin{lstlisting}
    A=1
    B=2
    C=3
  \end{lstlisting}
&
  \footnotesize{
  \begin{verbatim}
  fAnd( fEq (fVar (A _) fInt (1 _))
        fAnd(fEq (fVar(B _)) fInt(2 _) 
             fEq(fVar(C _) fInt(3 _))))
  \end{verbatim}
  }
\end{tabular}

\subsection{Declarations}\label{sec:input:flocal}
Declarations are found in records of the form fLocal(Declarations Body Pos), where declarations and Body are both AST subtrees. 
For example:

\begin{lstlisting}
local
  A B C
in
  A=1
end
\end{lstlisting}
will give
\begin{verbatim}
fLocal(
       fAnd(
            fVar(A _) 
            fAnd(
                 fVar(B _) 
                 fVar(C _) 
                 _) 
            _) 
       fEq( 
            fVar(A _) 
            fInt(1 _) ))
\end{verbatim}

\subsection{Procedures}\label{sec:input:procedures}
\subsubsection{Definitions}
Procedures are found in records of the form fProc(Name Arguments Body Flags Pos), where the Arguments and Body features are AST subtrees. %FIXME: what can be Name? fVar, $. Other possibilities?
Example:

\subsubsection{Calls}
%FIXME: distinguish arguments and parameters?
Procedure calls are found in records of the form fApply(Proc Arguments Pos). 
Example:

\begin{lstlisting}
  {Compute 1 2 3}
\end{lstlisting}

will result in the AST portion:
\begin{verbatim}
fApply(
       fVar(Compute _)
       |(fInt(1 _)
         |(fInt( 2 _)
           |fInt( 3 _))))
\end{verbatim}

\subsection{Functions}\label{sec:input:functions}
Funtion definitions are found in the AST un fFun records, with the same features found in fProc records. Functions are simply procedures that implicitly return exactly one value. This similarity between functions and procedures can be seen in their similar AST for definitions and calls. This similarity will be exploited later on to merge both forms of AST into one.
However, only functions can be marked as lazy as in \lstinline!fun lazy {F N} .. end!. This lazy marker is translated in a flag.
\subsubsection{Definitions}
Function definitions are found in records fFun(Name Arguments Body Flags Pos). The features are identical to the procedure definition.
\subsubsection{Calls}
The calls of functions are identical to the call of procedures as they are found in fApply.
\subsection{Arithmetic operators}\label{sec:input:operators}
Arithmetic operators are parsed as records of the form fOpApply(Operator Args Pos), which first feature is the operator to apply, and its second feature being the list of operands. It also has a position record as third feature. For example
\lstinline!5+2! is parsed as:
\begin{lstlisting}
      fOpApply(
         '+'
         |(
            fInt(5 pos)
            |(
               fInt(2 pos )
               
            )
         )
         pos
      )

\end{lstlisting}
\subsection{Nesting marker \$}\label{sec:input:nestingmarker}
In Oz, some statements can be transformed in expressions by the use of the \$ marker. This marker is found in the AST as a record fDollar() with a unique feature: it position.
The statements that can be transformed in expressions are
\begin{itemize}
  \item Function, Procedure, Functor and Class declarations. For example X=fun{\$ A B} .. end
  \item In the parameters list of a call to a procedure, in the location of an expression. For example {Foo A..\$..N}
  \item In a pattern position of a parameter of a call. For example {Foo bar(A..\$..N) baz}
\end{itemize}
Note that although functions can unify their parameters with values, like in 
\begin{lstlisting}
  fun {F A ?R2}
     R2=3*A
     2*A
  end
\end{lstlisting}
It makes absolutely no sense to put a nesting marker as second argument to a call of this function, like in 
\lstinline[mathescape]!{F 2 $\$$}! because the call itself is already an expression.


\subsection{Cells}
\subsubsection{Assignation}
fColonEquals(Cell Val Pos) %FIXME
\subsubsection{Read}
fAt(Cell Pos) % FIXME
\subsection{Records}\label{sec:input:records}
Without describing the whole syntax, here is a reminder of the record syntax in Oz code. A record is refined by \lstinline!Label(F1:V1 F2:V2)! where the label and features ($F_i$) can be an atom or a variable, and the values ($V_i$) can in addition to this be the result of a function call. Features can be left out, in which case they are implicitly assigned increasing values from 1.

Records are present in the AST in records with label fRecord. Its label is the first feature, and the second feature is the list of feature/value pairs. If no feature was specified, the entry in the list is simply the value. If a feature was specified, the entry in the list is a record fColon, with the first feature being the feature and second feature being the value. All this will become much clearer with the following examples.

Here is the AST corresponding to the record definition \lstinline!rec(f1:v1 f2:v2)!. We see that the label (rec) is an atom located in an fAtom record. The pairs of features and their respective values are wrapped in fColon.

\begin{lstlisting}
   fRecord(
      fAtom(rec pos)
      |(
         fColon(
            fAtom(f1 pos)
            fAtom(v1 pos)
         )
         |(
            fColon(
               fAtom(f2 pos)
               fAtom(v2 pos)
            )
            nil
         )
      )
   )
\end{lstlisting}

When the feature is not explicitely given, the item in the list of features and their respective values is simply the value. Here is the AST of this record \lstinline!rec(v1 f2:V2)!. The first item in the list is simply an atom, the value of the first feature. Note that the value of the feature f2 is a variable in this case.

\begin{lstlisting}
   fRecord(
      fAtom(rec pos)
      |(
         fAtom(v1 pos)
         |(
            fColon(
               fAtom(f2 pos)
               fVar(V2 pos)
            )
            nil
         )
      )
   )
\end{lstlisting}


\subsection{Wildcards}\label{sec:input:wildcard}
Oz syntax allows to put a wildcard \lstinline!_! in the location of a value we want to ignore, for example in calls and records pattern matching. These markers are present in the AST in the form of a record \lstinline!fWildcard(Pos)!.
Ignoring the value returned by a function is thus written \lstinline!_={F N}!. 
This allows the user to not declare variables he wouldn't use anyway, which would in addition raise a warning about a variable used only once\ldots

Pattern matching is covered extensively in Section \ref{sec:input:patternmatching}.

\subsection{Threads}
Thread instructions are present in the AST in the form of records with label fThread, and with two features: the body of the thread, and its position in the source code:
\begin{lstlisting}
   thread Body end
\end{lstlisting}
results in
\begin{lstlisting}
   fThread(Body pos)
\end{lstlisting}
\subsection{Locks}
Oz enables the programmer to protect a critical section with a lock previously create with \lstinline!L={NewLock}!:
\begin{lstlisting}
   lock L then
      % critical section
   end
\end{lstlisting}

This code results in a fLockThen record in the AST, with 3 features: the lock L, the body of the critical section, and the position in the code.
\subsection{If then else}
The if..then..else construct is put in records:
fBoolCase( Condition ThenCode ElseCode)
The else part is optional in Oz. In this case, ElseCode is a record \lstinline!fNoElse(pos)! in the AST.
\subsection{Boolean combinations}\label{sec:input:booleancombinations}
The boolean conjunction operation in Oz represented by the keyword \lstinline!andthen!. Such a conjunction is present in the AST in the form of a record \lstinline!fAndThen(First Second)!, where first and second must be expressions with a boolean value.
The boolean disjunction operation is done thanks to the keyword \lstinline!orelse!, present in the AST in the form of a record \lstinline!fOrElse(First Second)!.
\subsection{Case Instruction and Pattern Matching}\label{sec:input:patternmatching}
The Case instruction in Oz is of the following form where optional parts are enclosed in double square brackets ([[ ]]).
\begin{lstlisting}
   case Value                           % _
   of Pattern1 [[andthen Guards1]] then %  \____ This is a clause
     Code1                              % _/
   [] Pattern2 [[andthen Guards2]] then
     Code2
   ..
   [[else
     ElseCode]]
   end
\end{lstlisting}
This ends up in the AST in a record of the form \lstinline!fCase(Value Clauses ElseCode pos)!.
\lstinline!Clauses! is a list of records each representing one clause and containing the clause' pattern, guards and code. We will analyse these further below.
The else part of the instruction is optional. If no else is provided, then ElseCode in the AST is a record \lstinline!fNoElse(pos)!.

A clause with no guards is present in the AST in the form of a record \lstinline!fCaseClause(Pattern Body)!. \lstinline!Pattern! can be a constant value (integer, string, record, \ldots), present in the AST as described earlier. It can also be a record where a feature value is not a constant but a variable (in a \lstinline!fVar(Name pos)! record as described in section \ref{sec:input:variables}). In case of a match of the constant feature values in the pattern, this declares said variable and assigns the value of the corresponding feature in the value the pattern is tested against. Here is an example:
\begin{lstlisting}
  R=lab(a b c d)
  case R
  of lab(a B c d) then
    {Show B}  % B's value is b
  end
\end{lstlisting}
Features of a record in a pattern can also have the wildcard \lstinline!_! as value, represented in the AST as described in section \ref{sec:input:wildcard}.

The pattern can also be or contain an open record specifying only the first features which should match, as in the following example:
\begin{lstlisting}
  R=lab(a b c d)
  case R
  of lab(a b ...) then
    % Code for record with label lab
    % and value a and b for two first features.
  end
\end{lstlisting}
The syntax for an open record pattern is the same as for a record pattern, except that subsequent features that should be ignored are replaced by \lstinline!...!. Also in the AST an open record is very similar to a record. Only the label changes to \lstinline!fOpenRecord!, and only the specified features are present in the AST, the \lstinline!...! being absent from the AST. Here is an example of an open record:
\lstinline!lab(a b ...)! 
and its AST representation:
\begin{lstlisting}
   fOpenRecord(
      fConst(lab pos)
      |(
         fColon(
            fConst(1 pos)
            fConst(a pos)
         )
         |(
            fColon(
               fConst(2 pos)
               fConst(b pos)
            )
            nil
         )
      )
   )
\end{lstlisting}

Records and open records can of course be nested.

A clause with guards is present in the AST in the form of a record \lstinline!fSideCondition(Pattern Decls Guards Pos)!, where \lstinline!Pattern! is as above, Decls is usually skipped (\lstinline!fSkip(pos)!)%FIXME: what are decls??
and Guards is simply the AST of the code of the guard (without the \lstinline!andthen! introducing the guard).
Guards must be an expression with a boolean value, possibly using the boolean combinations of section \ref{sec:input:booleancombinations}.

% FIXME: add !Var and conjunctions


\chapter{Compiler}
\section{Architecture}
The AST received from the parser goes through several transformations. These transformations are implemented by functions taking as only argument the AST, and they return the transformed AST.
These functions all have the same structure:
\begin{figure}[h]
\begin{lstlisting}
   fun {Transform AST}
      fun {TransformInt AST Params}
         case AST
         of ... then
         else
            {DefaultPass AST TransformInt Params}
         end
      end
      InitialParams = ...
   in
      {TransformInt AST InitialParams}
   end
\end{lstlisting}
\caption{Structure of a transformation function}
\end{figure}
Having the same structure enables the use of the function \lstinline!DefaultPass!, which calls the function passed as second arguments recursively on the AST with \lstinline!Params! as last argument, but returns the AST unchanged. This facilitates the recursive calls for default behaviour on elements not modified by the transformation.
Params if a record with label \lstinline!params!, and features are added according to use. For an example, this \lstinline!Params! argument is used by the \lstinline!Globaliser! described in Section \ref{sec:arch:globaliser}.
Although all passes work exclusively on the AST, the transformations described in later sections can and will often be illustrated more clearly and concisely by giving the Oz code corresponding to the ASTs before and after the transformation. 

\subsection{Declarations Flattener}\label{sec:arch:declsflattener}
The Oz language accepts complex instructions in the declaration part of \lstinline!local Decls in Body end!. This brings the need to decide what variables are declared for each instruction present in the \lstinline!Decls!. 
For example, in unification, only the left hand side variable gets declared, and only B is implicitely declared in the following code snippet:
\begin{lstlisting}
   local
      B=2*A
   in
      ...
   end
\end{lstlisting}
Luckily, this has been clearly formalised by the Oz implementers and published on the web\footnote[]{http://www.mozart-oz.org/documentation/notation/node6.html}. This information has been included in Appendix \ref{appendix:patternvariables}. The namer simply applies these rules to move all code to the \lstinline!Body! beginning, keeping only simple variable declarations in \lstinline!Decls!.

\subsection{Namer}\label{sec:arch:namer}
The namer  basically replaces all occurences of a variable's \lstinline!fVar! by \lstinline!fSym! records holding a symbol instance representing said variable. All uses of a variables are replaced by the same symbol instance. This symbol holds information about the variable, that will be completed by subsequent compiler passes, such as the type of the symbol, its allocated register,\ldots and is documented in Appendix \ref{appendix:symbol}.

In declarations, the namer creates a new symbol for the declared variables, in other code, it looks at already defined symbols and replaces \lstinline!fVars! by a \lstinline!fSym! record containing the existing symbol for that variable. This works because a variable can only be used after it has been declared. The namer can thus be sure to find a symbol for variables it encounters in the AST, or it is an error.

The set of maps from a variable name to its corresponding symbol is called environment, and is maintained by the namer.

\subsubsection{Declarations}
So the question raises of when do variables get declared.
One such construct is of course the explicit declaration instruction \lstinline!local Decls in Body end!, present in the AST in the form of \lstinline!fLocal! records introduces in section \ref{sec:input:flocal}. At this stage, \lstinline!Decls! only contains simple variables declaration, thanks to the declaration flattener (see Section \ref{sec:arch:declsflattener}). \lstinline!fLocal! introduces a new environment, in which the variables declared in its first feature are added to the environment of the code present in its second feature, possibly erasing mappings for variables with the same name coming from the parent environment. 

Another kind of declaration is found in the definition of procedures and functions. Indeed, fProc (section \ref{sec:input:procedures} and fFun (section \ref{sec:input:functions}) records also implicitely declare the variables for their formal parameters. % see test 029

Still another kind of declaration happens in pattern matching (section \ref{sec:input:patternmatching}), when a record present in the pattern has a feature that is a variable. This case is analysed specifically in section\ref{sec:arch:namer:patternmatching}.

These variables get implicitely declared and added to the environment in which not only the clause' body but also its guards will be executed.


It is these manipulations of the environments that make that the code in Figure~\ref{fig:namer_nested_locals} does not throws an error of impossible unification of A with 6. Indeed, the inner variable A gets another symbol assigned than the outer one, and replaces it in the environment of the inner instructions. Thus there is no ambiguity in the \lstinline!Show! instruction as to which its argument is, and it effectively shows 6.
\begin{figure}
\begin{lstlisting}
local
   A=5
in
   local 
      A=6
   in
      {Show A}
   end
end
\end{lstlisting}
\caption{Nested locals handled by Namer}
\label{fig:namer_nested_locals}
\end{figure}


\subsubsection{Non-declaration code}
In code not declaring variables, the namer's job is much simpler: it will simply replace all occurences of fVar records by a fSym record having the corresponding symbol as first feature.
\subsubsection{Case Pattern Matching}\label{sec:arch:namer:patternmatching}
For pattern matching with the \lstinline!case! instruction the namer will have more work to do, which we will discuss now. Let's note \lstinline!PatternX(Var1,Var2,..)! the pattern identified by X and implicitely declarng variables \lstinline!Var1!,\lstinline!Var2!,\ldots, and let's use the same convention for code fragments \lstinline!CodeX(Var1,Var2,..)! and guards \lstinline!GuardsX(Var1,Var2,..)! using those implicitely declared variables.

The transformation of the AST corresponding this Oz code:
\begin{lstlisting}
case Val
of Pattern1(A,B) andthen Guards1(A) then
   Code1(A,B)
[] Pattern2(B,C) andthen Guards2(C) then
   Code2(B,C)
else
   ElseCode
end
\end{lstlisting}
results in an AST corresponding to this Oz code:
\begin{lstlisting}
local
  A1 B1 B2 C2
in
   case Val
   of Pattern1(A1,B1) andthen Guards1(A1) then
      Code1(A1,B1)
   [] Pattern2(B2,C2) andthen Guards2(C2) then
      Code2(B2,C2)
   else
      ElseCode
   end
end
\end{lstlisting}

Here is the way how it is achieved. The compiler traverses each clause in turn,
and collects all symbols introduced during this operation. It creates a new
environment for this clause, which is updated with captures done in the
pattern. After that, the namer traverses the ASTs of the Guards and the Code
using this updated environment. and restores the original environment, on which
the next clause will build its own environment. This shows clearly that
although all capture variables are are technically reachable from all clauses'
bodies, it will never be the case as the environment on which a clause builds
its own is the environment of the case instruction, not the environment updated
by the previous clause. 

%FIXME: add reference
In addition, the \lstinline!fSym! record corresponding to these capture
variables are themselves stored in an unforgeable secure structure (as
described in CTMCP Section 3.7.5) which is itself wrapped in an
\lstinline!fConst!. The reason of this manipulation is to prevent manipulations
of those symbols by later compiler passes. Now these will be handled as
constants in all subsequent compiler passes. Another consequence of this is
that the records implicitely declaring variables in a pattern are seen as
constant records, all features being constants! And these are treated as such,
notably in the desugaring of records (section \ref{sec:arch:desugar:records}).



\subsubsection{Compiler Code Notes}
The namer is one function unimaginatively named \lstinline!Namer! taking as argument an AST, and returning the resulting AST.
These local functions are defined: \lstinline!NamerForDecls!,\lstinline!NamerForBody!,\lstinline!NamerForCaptures!.
Notice that NamerForBody calls NamerForDecls when a function or procedure is defines, and NamerForCaptures when captures are present in patterns. Here is for example the code handling a function definition in non-declaration part of the code:

\begin{lstlisting}
  %---------------------------------
  [] fFun(Name Args Body Flags Pos) then
  %---------------------------------
     Res
  in
     {Params.env backup()} 
     Res=fFun(
        % The function's variable has to be declared explicitely in the declaration part.
        % That's why we call NamerForBody on the Name
        {NamerForBody Name Params}
        % Formal parameters are declarations, that's why we call NameForDecls
        {List.map Args fun {$ I} {NamerForDecls I Params} end }
        {NamerForBody Body Params}
        Flags
        Pos
     )
     {Params.env restore()}
     Res
\end{lstlisting}
The environment, mapping variable names to their respective symbol, is stored in the object available through Params.env. This object's \lstinline!backup! method will backup the current environment and create a new one with the exact same bindings.
We see in this code that the function creates a new environment based on its parent environment, which is backuped to be restored when done. The name of the function is passed to \lstinline!NamerForBody!, because the name of the function must have been declared previously and be present in the environment. 
The formal parameters of the function however are passed to \lstinline!NamerForDecls!, as these are variables implicitely declared, that have to be added to the current environment. This updated environment is then used by \lstinline!NamerForBody! to transform the function's body.
At the end, the parent's environment is restored, ensuring that formal parameters of the function are not available outside of the function.

This code also illustrates how it comes that functions can access variables defined in the defining environment (such functions are called closures): all those are inherited by the function's environment!




\subsection{Desugar}\label{sec:arch:desugar}
The desugar pass handles the transformation of syntactic sugar code in its canonical form.
Oz distinguishes two groups of instructions: statements and expressions. An expression is ``syntactic sugar for a sequence of operations that return a value'' . Statements do not return a value.
The desugar function handles statements and expression differently, and defines two local functions, one for handling expressions, one for handling statements.
\subsubsection{On statements and expressions}
%FIXME: Give references: Concepts, Techniques and Models of Computer Programming, p81.
Handling expressions and statements is often very similar, but sometime require significant differences of treatment. Hence the use two different local functions in the Desugar pass.

From this raises the question of categorising an instruction as a statement or an expression. And this is not as straightforward as one may think, as the context in which the instruction is used can change the type of an instruction from statement to expression. This is illustrated by the following example.
% FIXME: storage element?? Find better name.
In Oz, a cell is a mutable storage element which is created with an initial value (\lstinline!C={NewCell 0}!), it can be given a new value (\lstinline!C:=NewValue!) and its value can be read (\lstinline!@C!). There's also an exchange operation \lstinline!{Exchange C Old New}! which ``atomically binds Old with the old content of the cell, and set New to be the new content''.%FIXME: reference pvr book page 415.
Assigning a new value to a cell is usually a statement returning no value, but when used as the right hand side of an assignment, it becomes an expression, whose value is the Old value of the cell !
\begin{figure}[h]
\begin{lstlisting}
local
  C={NewCell 0}
  Old
in
  C:=1        % statement
  Old=(C:=2)  % expression, whose value is assigned to Old
  {Show Old}  % displays 1
end

\end{lstlisting}
\caption{Cell assignment as statement and as expression}
\label{fig:statement_and_expression1}
\end{figure}
Another illustration is the instruction \lstinline!local ... in ... end! which can be a statement as in Figure \ref{fig:statement_and_expression1}, but also an expression as in the code snippet in Figure \ref{fig:statement_and_expression2}

\begin{figure}[h]
\begin{lstlisting}
   A = local C=2 in 2*C end
   {Show A}
\end{lstlisting}
\caption{local \ldots in \ldots end as an expression}
\label{fig:statement_and_expression2}
\end{figure}

Determining if an instruction is a statement or and expression is done
recursively from top to bottom, the starting case being that the program is a
statement, the ending case being that variables, constants, base operators,
\ldots are expressions.  In Figure \ref{fig:statement_and_expression1}, the
whole code snippet which we consider in this case as a complete program is a
statement. This \lstinline!local...in...end! instruction is thus a statement.
The declaration part of this instruction is always a statement. The body is
also a statement because the whole local...in...end is a statement. If it were
an expression (as in Figure \ref{fig:statement_and_expression2}), the body
would have been an expression! In our case, the body is a sequence of
instructions, resulting in a hierarchy of fAnd records in the AST. Thus we see that a sequence
can be a statement or an expression, in which case the value
of the whole sequence is the value of the last instruction which must be an expression. This illustrates the
need of distinct functions when statement and expressions must be handled
differently. 

The fact is that the character (statement or
expression) of a sequence of instructions is determined at the start of the
sequence, the top of the fAnd hierarchy in the AST. But the impact of this
distinction is found at the very bottom of this hierarchy: the last
instruction, the end of the sequence. To be able to distingish both cases, we
need to branch as soon as we determine the instruction's character.

If we note F the pass of the compiler, FExpr the locally defined function handling expressions, and FStat corresponding function for statements, we can ensure that the right function is applied to each instruction's AST as defined in section \ref{section:compilerinput} by following these rules of identification, and call FStat on statements and FExpr on expressions:

%FIXME possibly replace the AST record by the Oz instruction they represent
\begin{description}
  \item[program] the program is a statement
  \item[fLocal] 
    \begin{itemize}
      \item the declarations are all just fSym, since the DeclsFlattener has move all other code to the body. These fSyms are neither expressions nor statement, they are just fSym declarations, and the declaration part is a statement.
      \item the body has the same character as its parent fLocal
    \end{itemize}
  \item[fAnd] 
    \begin{itemize}
      \item the first feature is a statement
      \item the second feature has same character as its parent fAnd
    \end{itemize}
  \item[fEq] both sides are expressions
  \item[fProc] if the proc definition is an expression, its identifier must be the nesting marker \$, else its identifier is an expression. The arguments are expressions, and the body is a statement.
  \item[fFun] are similar to fProc, because a function definition is desugared in a procedure definition as described in Section \ref{sec:arch:desugar:functions}.
  \item[fApply] calls can be statements or expressions, but in both cases the callee and its arguments are all expressions. 
  \item[fColonEquals] can be statement or expression, but Cell and Val are in both cases expressions.
  \item[fAt(Cell Pos)] is an expression, as is Cell
  \item[fSym] , outside of \lstinline!local..in..end!'s declaration part, are expressions
  \item[fConst] are expressions
  \item[fRecord] are expressions, as are its label and values.
  \item[fCase] can be a statement or an expression. The \lstinline!fCaseClause!s and the else code have the same type as their parent fCase. The patterns in the \lstinline!fCaseClause!s are expressions, as are the guards.
\end{description}

%FIXME: do i keep this next paragraph?
All expressions and statements in the AST will be visited by Desugar. Even if the statement itself is not transformed, as is the case for a unification, its children will be visited and possibly transformed. For example
X=5+2 will still be a unification after it's been desugared, but its children will have been transformed in X={Number.'+' 5 2}.



\subsubsection{Arithmetic operators}
Infix arithmetic operators are transformed in the call of their respective function.
The operators are parsed as fOpApply records as described in section \ref{sec:input:operators}. Building further on the example of that section, the AST coming from the parser

\begin{verbatim}
      fOpApply(
         '+'
         |(
            fInt(5 pos)
            |(
               fInt(2 pos)
               
            )
         )
         pos
      )
\end{verbatim}
will be transformed in:
\begin{verbatim}
      fApply(
         Number.'+'
         |(
            fInt(5 pos)
            |(
               fInt(2 pos)
               
            )
         )
         pos
      )
\end{verbatim}

\subsubsection{Functions}\label{sec:arch:desugar:functions}
Functions are transformed in their canonical procedure form. This is done simply by replacing the function by a procedure with exactly the same characteristics, except that it takes one additional argument (the return value), and the body of this procedure is the unification of this new argument with the original body of the function. This resulting AST is itself recursively ``desugared''.

For example, the code
\begin{lstlisting}
   fun {F A B}
      A+B
   end

\end{lstlisting} 
is parsed as:
\begin{verbatim}
      fFun(
         fSym(F pos
         |(
            fSym(A pos)
            |(
               fSym(B pos)
               nil
            )
         )
         fOpApply(
            '+'
            |(
               fSym(A pos)
               |(
                  fSym(B pos)
                  nil
               )
            )
            pos
         )
         
         pos
      )
\end{verbatim}
and transformed by the desugar pass to become:
\begin{verbatim}
     fProc(     
         fSym(F)
         |(    
            fSym(A pos)
            |(
               fSym(B pos)
               |(
                  fSym(R pos)
                  
               )
            )
         )
         fEq(
            fSym(R)
            fApply(
               fConst('+' pos
               |(
                  fSym(A pos)
                  |(
                     fSym(B pos)
                     nil
                  )
               )
               pos
            )
            pos
         )

         pos
      )

\end{verbatim}

We can also illustrate this transformation in Oz code. For the same example, the resulting Oz code is
\begin{lstlisting}
   proc {F A B ?R}
      R={Number.'+' A B}
   end
\end{lstlisting} 
We see that a new symbol, that we denoted R for convenience, is added to the arguments list of the procedure, and this new symbol is then unified with the body of the original function. This unification will in turn be handled by the unnester, which is the next pass of the compiler.

Lazy functions have in their flags a lazy atom: \lstinline!fAtom(lazy pos)!.
The desugar step of lazy function simply revolves in wrapping in a thread a call to the builtin \lstinline!waitNeeded! on the return symbol before unifying it with the body of the function. If the function of the example we worked on until now had been marked as lazy, the transformation would have yielded this result, in Oz notation:
\begin{lstlisting}
   proc {F A B ?R}
      thread 
         {WaitNeeded R}
         R={Number.'+' A B}
      end
   end
\end{lstlisting} 

\subsubsection{Records}\label{sec:arch:desugar:records}
As mentioned in the description of records in Section \ref{sec:input:records}, the features can be left out, and are in that case implicit, with increasing integer values starting at 1. The Desugar pass will make this features explicit.

In Oz syntax, it means that \lstinline!rec(a b c)! is transformed in \lstinline!rec(1:a 2:b 3:c)!. Of course, attention has to be paid by the programmer to avoid conflict, as implicit feature assignment does not check for explicit features'values, and conflict can arise. For example \lstinline!rec(a 1:b c)! will be transformed in \lstinline!rec(1:a 1:b 2:c)!. This behaviour is coherent with Mozart 1, but causes an error. %FIXME: check this is all ok.
An additional action was added in the desugar step for records. First, \lstinline!fRecord! that have all label, features and values constant are replaced by a \lstinline!fConst! with as value the record reconstructed. This greatly simplifies the AST for these records as is illustrated in the next example, and can be done because the value of the record can be used as is in later steps, notably the opcodes generation. 
\begin{lstlisting}
      fRecord(
         fAtom(rec pos)
         |(
            fColon(
               fInt(1 pos)
               fAtom(a pos)
            )
            |(
               fColon(
                  fInt(2 pos)
                  fAtom(b pos)
               )
               nil
            )
         )
      )
\end{lstlisting}
is transformed in
\begin{lstlisting}
  fConst( rec(1:a 2:b) pos)
\end{lstlisting}


Records with non constant labels and/or features are replaced by a call to \lstinline!Boot_Record.makeDynamic!. The goal of this transformation is to leave in the AST only records with constant label and features. MakeDynamic takes two arguments. First the label of the record to construct. And second, a tuple with label '\#' and which values are alternately the features and their respective value. As a result, we replace \lstinline!Rec(F1:V1 F2:V2)! by \lstinline!{makeDynamic Rec '#'(1:F1 2:V1 3:F2 4:V2)}! .
In the AST, this replaces 
\begin{lstlisting}
  fRecord(Label 
          |(fColon(Feature1 Value1 pos)
            |(fColon(Feature2 Value2 pos)
              nil))
  )
\end{lstlisting}
where Label, Feature1 and Feature2 can be fSyms, by
\begin{lstlisting}
  fApply(
         fConst(makeDynamic pos) 
         |(Label
           |(fRecord(fConst('#' pos) 
                        |(Label
                           |(fColon(1 Feature1)|
                             |(fColon(2 Value1)|
                               |(fColon(3 Feature2)|
                                 |(fColon(4 Value2)|
                                   nil))))))
             nil)
          )
\end{lstlisting}
We see that we end up with a AST that only contains records with constant label and features: only the values are not constants.
%FIXME: why do this transformation?
Although this is not strictly a desugar step, it was added here to avoid adding a compiler pass only for this action.
\subsubsection{Wildcards}
Although the programmer is not interested in these values, the compiler will declare and place a new synthetic symbol in each of these locations. In oz code notation, \lstinline!_! is replaced by the expression \lstinline!local NewSymbol in NewSymbol end!.

\subsubsection{Threads}
%FIXME: is the following correct?
As expression, threads are present at this stage in the form, in Oz notation, \lstinline!V = thread Body end!, and this is desugared in the resulting statement \lstinline!thread V=Body end!. This statement is then itself desugared.
Transforming a thread statement is more involved, though still quite simple. The transformation consists in the creation of a procedure with no argument which body is the desugared body (which is a statement) of the thread, and then passing this procedure the internal \lstinline!Thread.create! procedure.
In Oz notation, \lstinline!thread Body end! is transformed in 
\begin{lstlisting}
   local 
      P 
   in 
      proc {P} 
         DesugaredBody 
      end 
      {Thread.create P}
   end
\end{lstlisting}
This transformation occurs in the AST of course, and here is the AST transformation illustrated. \lstinline!fThread(Body Pos)! is transformed in this AST (taken from the compiler source code):
\begin{lstlisting}
  fLocal(NewProcSym 
         fAnd( fProc(NewProcSym nil {DesugarStat Body Params} nil pos) 
               fApply(fConst(Boot_Thread.create pos) [NewProcSym] pos)
             ) 
         Pos)
\end{lstlisting}

\subsubsection{Locks}
Locks statements are handled very similarly to thread statements: their body is wrapped in a argumentless procedure, which is passed as argument, together with the lock itself, to the base environment's LockIn. In Oz notation, \lstinline!lock L then Body end! is transformed in
\begin{lstlisting}
local
   P
in
   proc{P}
      Body
   end
   {LockIn L P}
end
\end{lstlisting}


\subsubsection{If then else}
The condition tested is always an expression.
The instruction \lstinline!if..then..else..end! can be a statement as in 
\lstinline!if Cond then {DoTrue} else {DoFalse} end!
, in which case both code branches are desugared as statement
or an expression as in
\lstinline!X=if Y>Z then bigger else smallerOrEqual end!
in which case both code branches are desugared as expression.
A fNoElse record is left as is and will only be useful for the opcode generation function.

\subsubsection{Compiler Code Notes}
The desugar pass is implemented by a function named \lstinline!Desugar!. It defines multiple local functions:
\begin{description}
  \item[DesugarOp] called to desugar operators
  \item[DesugarRecordFeatures] working on record features, making them explicit if need be, and also desugaring the value corresponding to each feature.
  \item[TransformRecord] called to transform records as described above, just after it has been desugared.
  \item[IsConstantRecord] called by \lstinline!TransformRecord! to determine if the record for which the AST is passed as argument is a record with constant label, features and values
  \item[HandleLazyFlag] will wrap the body of a function in a thread if needed, as described in Section \ref{sec:arch:desugar:functions}.
  \item[DesugarExpr] called by \lstinline!Desugar! to desugar expressions
  \item[DesugarStat] called by \lstinline!Desugar! to desugar statements
\end{description}

The program itself being a statement, the function Desugar simply call DesugarStat on the AST of the whole program. This will trigger further calls to DesugarExpr and DesugarStat that will traverse and transform the whole AST.

\subsection{Unnester}\label{sec:arch:unnester}
The unnester will result in an AST in which there are only elementary instructions. For example, after the unnester, the arguments of functions all are simple variables. The instructions susceptible to be unnested are inspected each in turn in the following subsections.
\subsubsection{Unification}\label{sec:arch:unnester:unification}
The unnesting result of a unification instruction depends on the elementary character of each side. \lstinline!fConst!, \lstinline!fSym!, lstinline!fDollar! and lstinline!fAtom! are considered elementary AST nodes. Considering the elementary charater of both sides of the unification, we have to handle three situations:
\begin{description}
  \item[Both elementary]In this case there is nothing to do
  \item[One complex, one elementary] The unnesting is done according what the complex instruction is: 
    \begin{description}
      \item[Call] This is code of the form \lstinline!V={P E1...En}!, which needs to be transformed in the form \lstinline!{P E1...En V}!, where the variable we assign to is passed as last argument of the call. Note this transformation is not done if one if the arguments is the nesting marker (see section \ref{sec:arch:unnester:nestingmarker}).
      \item[Sequence of instructions] In the AST, the sequence of instructions is available in a hierarchy of fAnd records. We also know that the value of a sequence of instructions is the value of the last instruction in the sequence. As a consequence, the unnesting of this type of unification is done by moving the unification to the second feature of the fAnd, and recursively unnest the resulting AST.
      \item[Declaration (local)] The value of a \lstinline!local..in..end! in a unification is the value of its body. Hence, the unification \lstinline!V = local declarations in body end! is moved in side the local's body resulting in the code \lstinline!local declarations in V=body end!. This clearly requires a recursive call as the body can be a sequence of instructions, which will have to be handled as described previously.
      \item[if then else] The unification is simply moved inside each branch, and the resulting code is further unnested. For example, \lstinline!V=if B then Is1 else Is2 end! is transformed in \lstinline!if B then V=Is1 else V=Is2 end!. This needs to be recursively unnested as Is1 and Is2 can be, for example,  sequences of instructions.
    \end{description}
  \item[Both complex] This is unnested by creating a new synthetic symbol, unifying it with the left side then with the right side, and unnesting the resulting code.
\end{description}
We need recursive calls, as is illustrated by the following example, also showing why this code works
\begin{lstlisting}
  3+4 = {Show}
\end{lstlisting}
It is transformed due to both sides being non-elementary, in this form in a first step:
\begin{lstlisting}
  local
     T
  in
     T = 3+4
     T = {Show}
  end
\end{lstlisting}
and finally in this form by the transformation of the assignment of a procedure call in the same procedure call with the return variable passed as additional argument:
\begin{lstlisting}
  local
     T
  in
     T = 3+4
     {Show T}
  end
\end{lstlisting}
The order of the assignments of the first step explains why this doesn't work:
\begin{lstlisting}
  {Show} = 3+4
\end{lstlisting}

\subsubsection{Calls}\label{sec:arch:unnester:calls}
All arguments are unnested one by one. Elementary arguments are left untouched
Complex arguments are extracted from the arguments list by:
\begin{enumerate}
  \item declaring a new symbol. 
  \item unifying this new symbol with the argument
  \item replacing the argument by the new symbol in the argument list.
\end{enumerate}

 This means the call is wrapped in a local..in..end, the declarations part declaring the new symbol, the body part unifying this symbol with the complex expression that was the original argument, followed by the (to be unnested) function call with the new symbol replacing the complex argument. When a call has multiple complex arguments, this results in a local..in..end hierarchy with the depth corresponding to the number of complex arguments. %FIXME: check if we can change the code to have only one local declaring all variables.

Here is an example of unnesting in Oz code:
\begin{lstlisting}
  {F {F2 A} B}
\end{lstlisting}
will be transformed in:
\begin{lstlisting}
  local
    NewVar
  in
    NewVar={F2 A}
    {F NewVar B}
  end
\end{lstlisting}

Of course, the function called can itself be the result of a function call, and this is handled too:
\begin{lstlisting}
  { {F1 A} B }
\end{lstlisting}
will result in an AST for this code:
\begin{lstlisting}
  local
    NewVar
  in
    NewVar = {F1 A}
    { NewVar B }
  end
\end{lstlisting}

\subsubsection{Declarations (local)}
The unnester will not touch at the declaration part of a \lstinline!local..in..end! instruction. It will only unnest the body.
\subsubsection{If then else}
The unnesting of the instruction \lstinline!if Cond then Branch1 else Branch2 end! depends on the type of Cond. 
\begin{itemize}
  \item If \lstinline!Cond! is elementary, the unnesting is done simply by unnesting the two branched.
  \item If \lstinline!Cond! is complex, a new symbol is created and unified with it. This is then followed by the \lstinline!if..then..else! instruction in which the complex condition is replace by the symbol newly introduced:
    \lstinline!if Cond then Is1 else Is2 end! becomes \lstinline!local S in S=Cond if S then Is1 else Is2 end!.
\end{itemize}

\subsubsection{Records}\label{sec:arch:unnester:records}
The values in a record can be of non-elementary form, for example a function call. This has to be extracted from the record definition and replaced by a new symbol which has been unified with the initial value. The work happening on the records is very similar to the work done on (function and procedure) calls. Rather than working on the procedure arguments, we work on the pairs feature-value and only handle the value. 
Here is an example where the value of a feature is an if expression.
\begin{lstlisting}
   R=rec(a:if B then 2 else V end b:2)
\end{lstlisting}
will be transformed in
\begin{lstlisting}
  local
    NewVar
  in
    NewVar=if B then 2 else V end
    R=rec(a:NewVar b:2)
  end
\end{lstlisting}
And this requires a new unnesting step (see the unnesting of unifications Section \ref{sec:arch:unnester:unification}) resulting in 
\begin{lstlisting}
  local
    NewVar
  in
    if B then NewVar=2 else NewVar=V end
    R=rec(a:NewVar b:2)
  end
\end{lstlisting}

Note that the unnester applies the exact same transformation to open records.


\subsubsection{Nesting Marker}\label{sec:arch:unnester:nestingmarker}
It is also the unnester that will handle the nesting marker and remove it from the AST. There are three cases that are handled.
\begin{description}
  \item[Definitions of procedures] At this step, if we found a nesting marker as the identifier of a procedure, it is necessarily in an assignment statement. The unnester needs to transform \lstinline[mathescape]!X=proc{$\$$ A..N}! in \lstinline!proc{X A..N}!.
  \item[As argument of a call] In this case, the nesting marker has to be replaced by the variable the expression is assigned to. For example, \lstinline[mathescape]!X={P A $\$$ B}! needs to be transformed in  \lstinline!{P A X B}!. Note that this transformation is excluding the unification transformation described earlier in section \ref{sec:arch:unnester:unification}: either there is a nesting marker and the symbol the call expression is assigned to replaces the nesting marker in the arguments list, OR the symbol the call expression is assigned to is added as last argument to the call and in that case no argument may be the nesting marker.
  \item[In matching an argument] %FIXME: to do
\end{description}

\subsubsection{Compiler Code Notes}
The unnester is implemented by a function called \lstinline!Unnester!. The unnester implements multiple local functions:
\begin{itemize}
  \item  \lstinline!IsElementary! will return if the AST passed as argument is elementary.
  \item  \lstinline!UnnestFEq! is called to unnest unification ASTs
  \item  \lstinline!BindVarToExpr! is the function called by \lstinline!UnnestFEq! when one side is elementary, and the other complex.
  \item  \lstinline!UnnestFApply! is called to unnest calls
  \item  \lstinline!UnnestFRecord! is called to unnest records and open records. Its structure is similar to that of \lstinline!UnnestFApply!.
  \item  \lstinline!UnnestFBoolCase! is called to unnest \lstinline!if..then..else! instructions.
\end{itemize}
\subsection{Globaliser}\label{sec:arch:globaliser}            
This pass handles the global variables of a procedure, that is, variables used by a procedure that it does not declare (implying that the declaration is done at an upper level). It is interesting to note that the concept of global variables is only defined for procedures.
Just as locals attached an environment to their body, procedures attach their own unique procId to their arguments, declarations and body.
Symbols for variables declared by a procedure, including formal parameters, get assigned the procId of said procedure.

Special attention has to be paid to nested procedure declarations.
The globals of procedures in the code have to be determined from the inside to the outside: determine the globals of the deepest nested procedure, and go up. 
The globals of a procedure are:
\begin{itemize}
  \item all variables it uses directly (i.e. not in a procedure definition)
  \item plus the globals of all the procedures it defines
  \item minus the variables it declares itself
\end{itemize}

Here is an example:
\begin{lstlisting}
A=1
proc {P1}                 % A is global to P1
   B=2
   P2
in
   proc {P2}              % A and B are globals to P2
      P3 
   in
      proc {P3}           % A and B are globals to P3
         C
      in
         {Show A}
         {Show B}
         {Show C}
      end
      {P3}
   end
   {P2}
end
\end{lstlisting}


In the example we see that \lstinline!P3! uses 2 variables declared by another procedure: \lstinline!A! and \lstinline!B!. 
\lstinline!P2! does not directly use any variable, but it defines \lstinline!P3! which itself has 2 global variables. Those two variables are thus also globals to \lstinline!P2!.
\lstinline!P1! also does not use any variable directly, but it gets 2 globals from \lstinline!P2!, of which it declares one: \lstinline!B!. \lstinline!P1! indeed only has one global: \lstinline!A!.

In the abstract syntax tree, we replace symbols corresponding to a global variables by a new local symbol of type 'localised' referencing the symbol for this variables in the parent proc which might itself be a 'localised' symbol, and so on until we reach the level where the variables is declared.

%FIXME: add illustration of references to parent proc's variables

In the abstract syntax tree, \lstinline!fProc! is replaced by \lstinline!fDefineProc! taking 1 additional argument: the newly created local variables referencing a variable in the surrounding procedure. This additional information will enable the code generator handle global variables.

Handling globals correctly requires to handle numerous cases, and determining the algorithm to use requires some care, as illustrated by these examples:

\begin{lstlisting}
local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
end
\end{lstlisting}
In this case, \lstinline!A! is global to \lstinline!P3! and it creates a new local symbol that will reference a symbol local to \lstinline!P2!. But for \lstinline!P2!, A is also global, and this situation needs to trigger a new local creation in \lstinline!P2!, which will be referenced by the new local in \lstinline!P3!. Same thing in \lstinline!P1!.

\begin{lstlisting}
local
   A
in
   proc {P1}
      P2
   in
      {Show A}  % Use A before a defined procedure needs it
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
end
\end{lstlisting}

In this case, the traversal of the AST will first analyse \lstinline!{Show A}! and create a new local symbol for the variables \lstinline!A! in \lstinline!P1!. \lstinline!P2! is visited later and will create a new local to reference a symbol local to \lstinline!P2!, which is also a new local as \lstinline!A! is global to \lstinline!P1!. But this new local has already been created, and this situation must not trigger the creation of a new local symbol for \lstinline!A!. Rather, the new local symbol to \lstinline!P2! must reference the new local symbol to \lstinline!P1!. We see that the new local variables created in a procedure definition may have to be modified by its parent procedure.

Of course, the inverse has to be handled too, i.e. a new local is created for a defined proc, and reused later:

\begin{lstlisting}
local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
      {Show A}  % Use A after a nested proc triggered the creation of a new local.
   end
end
\end{lstlisting}


Also, a new local symbol must not be created when it would represent a locally declared variables, as in this case:

\begin{lstlisting}
local
   A
in
   proc {P1}
      P2
   in
      proc {P2}
         P3
      in
         proc {P3}
            {Show A}
         end
         {P3}
      end
   end
   {Show A}  % A is defined locally, and the nested procs defined should not trigger the creation of a new local, but P1's new local for A should reference the A declared by the local .. in .. end
end
\end{lstlisting}

Two procs defined at the same level must have have their respective new local symbols reference the same symbol at the parent level (whether it be a new local symbol created at the parent level or the existing symbol of a declared variable at the parent level). In this example, \lstinline!P2! and \lstinline!P3! each create a new local for \lstinline!A! and both trigger the creation of a new local in \lstinline!P1! for \lstinline!A!. But only one new local should be created in \lstinline!P1! for \lstinline!A!, and both locals in \lstinline!P2! and \lstinline!P3! should reference it.


Example V:
\begin{lstlisting}
local
   A
in
   proc {P1}
      P2 P3
   in
      proc {P2}
         {Show A}
      end
      proc {P3}
          {Show A}
      end
      {P2}
      {P3}
   end
   {Show A}  % Use A after a nested proc triggered the creation of a new local.
end
\end{lstlisting}

In the end, the algorithm used is the following.
Each call of the globaliser takes the AST sub tree and an additional \lstinline!Params! argument with three fields:
\begin{itemize}
   \item the current procId
   \item a list of global variables already seen in the current procId
   \item a list, each item being the list of new local symbols created for the global with same index in the previous list.
\end{itemize}

The globaliser handles the following nodes:
%FIXME: improve layout if the nest list?
\begin{description}
   \item[fProc] When handling a \lstinline!fProc!, the globaliser call gets the informations from the parent in its \lstinline!Params! argument. Because we enter a new level of procedure nesting, a \lstinline!NewParams! is initialised to be passed to recursive globaliser calls handling children nodes. NewParams is initialised with a new procId and two empty lists. 
      The symbol of the procedure itself gets the procId of its parent, found in \lstinline!Params!. The arguments of the procedure get the procId of the currently handled procedure, found in \lstinline!NewParams!. At that time the globaliser function is called recursively on the children nodes, with \lstinline!NewParams! as additional argument.
      Once all children have been traversed, the list of their globals and their respective newly created locals is found in \lstinline!NewParams!.  We have multiple new locals corresponding to one global in the case of 2 siblings procedure definitions referring the same global as in example V. 
      Globals whose procId match the \lstinline!NewParams!' procId are ignored, as those are variables that are declared at this level, and the chain of references must stop here for these variables.
      For each remaining global, we look at the list of their locals. 
      If one of these has the procId matching the current level, all other locals are changed to reference this one. This is because this specific symbol has been created by a direct use at this level, and we will use this one as the new localised symbol at this level. Then we push the global on the parent's globals list and add the local symbol to its corresponding list of new locals (those lists are found in \lstinline!Params!)
      If none of the locals has the current level's procId, it means the global variables has only been used in nested procedure definitions. We need to create a new local symbol for that variable at the current level that will be referenced by the existing locals. Finally, we push the global and the new local symbol we created to the parent via \lstinline!Params!. 
   \item[fSym] If the symbol in this \lstinline!fSym! has the current procId found in \lstinline!NewParams!, keep it as is, do not change it!  If its procId is different from the current procId, this \lstinline!fSym! represents a global variable for the current level. We look in \lstinline!Params! if a local variable with the current procId has already been created for this global variable. If yes we reuse it, else we define a new symbol, having the current procId and referencing the symbol initially in \lstinline!fSym!. We modify the \lstinline!fSym! to use that newly created symbol. Finally, push the global and its local to the parent.
   \item[fLocal] Simply assign the current procId to the variables declared by the instruction and recursively call the globaliser on the body.
\end{description}

\subsubsection{Compiler Code Notes}
The globaliser is implemented by a function called \lstinline!Globaliser!. It defines a local class \lstinline!GlobalsManager! used to ease the management of the newly localised symbols created and their relations to procIds. It also defines a function \lstinline!AssignScope! used to assign scope to variable declarations. \lstinline!Globaliser! transforms \lstinline!fProc!, \lstinline!fLocal! and \lstinline!fSym! nodes, leaves untouched the nodes \lstinline!fConst! and \lstinline!pos!, and raises an error if it finds a \lstinline!fVar! or \lstinline!fAtom!. All other nodes are traversed with the \lstinline!DefaultPass! function.

\subsection{CodeGen}
The last pass of the compiler will not return a new AST, but a list of opcodes to be passed to the assembler. It is implemented by the function \lstinline!CodeGen!, which is also responsible for register allocation to symbols present in the AST.

\subsubsection{Register allocation}
Currently, register allocation is very basic as all variable get a Y register assigned. This is far from optimal and offers a big opportunity for improving the performance of the compiled code.

\subsubsection{If then else}
Rather than give convoluted explanations, it is easier to look at the code generating the opcodes for \lstinline!fBoolCase(FSym TrueCode FalseCode Pos)! found in the AST for an \lstinline!if..then..else! instruction:
\begin{lstlisting}
  move({CodeGenInt FSym Params} x(0))|
  condBranch(x(0) ElseLabel ErrorLabel)|
  %---- true ----
  {CodeGenInt TrueCode Params}|
  branch(EndLabel)|
  %---- error ----
  lbl(ErrorLabel)|
  move(k(badBooleanInIf) x(0))|
  tailCall(k(Exception.raiseError) 1)|
  %---- else ----
  lbl(ElseLabel)|
  case FalseCode
  of fNoElse(_) then
     lbl(EndLabel)|nil
  else
     {CodeGenInt FalseCode Params}|
     % ---- end ----
     lbl(EndLabel)|nil
  end
\end{lstlisting}
It first moves the symbol containing the boolean to be tested in a X register, which is then used in a \lstinline!condBranch! opcode, taking as additional arguments the labels identifying the start of the else branch, and the start of the error handling code. The ``then'' branch directly follows the \lstinline!condBranch!. After that come the error code and the else branch. Note that at the end of the ``then'' branch, a branch opcode is needed to jump over the code corresponding to the else branch and the error handling. 
If no code is present in the else branch, no opcode is generated for that branch.

\subsubsection{Unification with Records}
At this step, the only place outside pattern matching (described later) where we can find records are in the right hand side of unifications, i.e. the second features of fEq, or in pattern matching which will be discussed later. 

The virtual machine requires, for performance reasons, the compiler to generate different opcodes for cons, tuples and records.
If the record is a cons, i.e. a record with label '|' and with exactly two features labeled 1 and 2, we need to issue a \lstinline!makeConsUnify(DestReg)!. 

If the arity is made of numbers only, i.e. we have the arity of a tuple, we need to issue a \lstinline!makeTupleUnify(k(Label) FeaturesList DestReg)! instruction. Else we need to issue a \lstinline!makeRecordUnify(k(Arity) FeaturesList DestReg)! instruction.
The function \lstinline!CompilerSupport.makeArity! is used to build the arity for use in \lstinline!makeRecordUnify!. It takes as argument the label and a list of pairs \lstinline!Label#Value!. If the labels passed in the list are labels of a tuple, it returns false, else it returns the constructed arity. It is based on the value returned by \lstinline!makeArity! that the compiler decides which instruction is issued.
The \lstinline!FeaturesList! has to be ordered according to the features. This is important, as the \lstinline!makeConsUnify!/\lstinline!makeTupleUnify!/\lstinline!makeRecordUnify! instructions have to be followed by \lstinline!arrayFill! instructions, one for each value, in the same order as the features passed to the instruction.

As an illustration, this unification of a variable with a record having one value not constant:
\begin{lstlisting}
R=rec(a:A b:2)
\end{lstlisting}
results in this AST
\begin{lstlisting}
   fEq(
      fSym('R' pos)
      fRecord(
         fAtom(rec pos)
         |(fColon( fAtom(a pos)
                   fSym('A' pos))
           |(fColon( fAtom(b pos)
                     fInt(2 pos))
             nil)))
      pos)
\end{lstlisting}
and, if we note \lstinline!y(Variable)! the register assigned to \lstinline!Variable! by the compiler, it results in these opcodes being generated:

\begin{lstlisting}
   makeRecordUnify( k(<Arity rec(a b)>) 2 y(R) )
   arrayFill(y(A))
   arrayFill(k(2)) 
\end{lstlisting}

\subsubsection{Procedures/Abstractions}\label{sec:codegen:procedures}
At this stage, only procedures are defined, as found in \lstinline!fDefineProc! records (created by the \lstinline!Globaliser!, see Section \ref{sec:arch:globaliser}) of the form:
\lstinline!fDefineProc(fSym(Sym pos) Args Body Flags Pos NewLocals)!
As described in Section \ref{sec:opcode:procedures}, the body has first to be assembled. This requires to first assign registers to all symbols used in the body, generating the opcodes for the body (which might itself define procedures and thus do recursive calls) and pass it to the assembler which will return the CodeArea we need.
The \lstinline!createAbstractionUnify! instruction can then be issued, unifying the assembled abstraction's code area \lstinline!CA! with the register assigned to the symbol \lstinline!Sym!:
\lstinline!createAbstractionUnify(k(CA) GlobalsCount {RegFor Sym})!
\lstinline!GlobalsCount! in this instruction is the integer number of global variables present in CA. Each global variable has to be initialised in turn by an \lstinline!arrayFill! instruction. The first \lstinline!arrayFill! will initialise the abstraction's \lstinline!g(0)!, the second will initialise the abstraction's \lstinline!g(1)!, etc\ldots
If the variable in the enclosing environment referenced by the localised symbol is located in a X register, say 0, then the global is initialised by arrayFill(x(0)). Similarly if the variables in the enclosing environment is stored in register Y or g at index 0, then the global will be initialised with arrayFill(y(0)) or arrayFill(g(0)) respectively.

\subsubsection{Unification}
Unification not involving records simply issue a \lstinline!unify(LHS RHS)! instruction, where LHS is the register where the left-hand side is stored and RHS is the register for the right-hand side.
\begin{lstlisting}
A=10
A=B
\end{lstlisting}
present in the AST in this form:
\begin{lstlisting}
   fAnd(
      fEq(
         fSym(Symbol(A) pos)
         fConst(10 pos)
         pos
      )
      fEq(
         fSym(Symbol(A) pos)
         fVar(Symbol(B) pos)
         pos
      )
   )
\end{lstlisting}

where \lstinline!Symbol(A)! (resp. \lstinline!Symbol(B)!) represents the instance of the class \lstinline!Symbol! corresponding to variable \lstinline!A! (resp. \lstinline!B!) in this part of the code. 

The opcodes generated for this AST are:

\begin{lstlisting}
will result in these opcodes being generated:
unify(y(1) k(10))
unnify(y(1) y(2))
\end{lstlisting}


\subsubsection{Calls}\label{sec:codegen:calls}
Calls are done with the opcode \lstinline!call(Callee NumberOfArgs)!. The arguments are not passed to \lstinline!call!, but will be accessed in registers X with index 0 to \lstinline!NumberOfArgs!. \lstinline!CodeGen! will thus first move all argument values to X registers, then issue the \lstinline!call!.
Let's have a look at this example code
\begin{lstlisting}
  {F A B 10}
\end{lstlisting}
and let's suppose that F is located in register y(0), B in y(2)  and A in g(2). 10 is accessed via register k(10) as described in Section \ref{sec:intro:opcode:registers}.
The opcodes generated for this call will be 
\begin{lstlisting}
  move(y(2) x(0))
  move(g(2) x(1))
  move(k(10) x(2))
  call(y(0) 3)
\end{lstlisting}

\subsubsection{Case}
Case statements are amongst the most complex instructions to handle in code generation. This is because different pattern types are handled differently. 


We'll start by ignoring guards for the moment and look at this code:

\begin{verbatim}
  case Val
                -------------------+
                ---+               |
  of Pattern1 then |->1 clause     |
     Body1         |               |
                ---+               |
  [] Pattern2 then                 |-> Clauses sequence for Mozart2 VM
     Body                          |
  ...                              |
  [] PatternN then                 |
     BodyN                         |
               --------------------+
  else
     ElseBody
  end

\end{verbatim}

The Mozart1 VM allowed the compiler to group in one test instruction subsequent clauses of
constant patterns (records, integers, atoms, floats,...), but open
record patterns could only be handled individually.
With the Mozart2 VM, both records and open records can be grouped in one test instruction.

A sequence of clauses is a group of subsequent clauses of the same type (constant or open record) and with no guards.
As sequence of clauses are grouped, the opcode generated will not
have one test instruction per clause, but one test instruction
per sequence of clause, and the test result will jump to the corresponding clause' body.

This will result in opcodes of this form when testing against the value in register x(0):
\begin{lstlisting}
  patternMatch(x(0) k('#'(Pattern1#lbl1 Pattern2#lbl2)))
  branch(NextTestLabel)
  lbl(1)
  Code for clause1
  branch(EndLabel)
  lbl(2)
  Code for clause2
  lbl(NextTestLabel)

  ... Other clauses ...

  lbl(EndLabel)
\end{lstlisting}

The patternMatch instruction takes two parameters: the register containing the
value to test against, and a constant record with label '\#' and with one
feature-value pair for each clause. 

The feature is the pattern to which two transformations have been applied. 

First capture variables have been replaced by an object obtained resulting from a call to
\lstinline!Boot_CompilerSupport.newPatMatCapture!, passing as unique argument
the X register index in which to store the value of the capture variable in
case this pattern matches. The value is the label identifying the start of the
code of the corresponding clause, which is where the patternMatch instruction
will jump in case of a match.

Second, open records have been replace by an object obtained resulting from a
call to \lstinline!Boot_CompilerSupport.newPatMatOpenRecord!, passing as
arguments the arity and features list of the open record.

The patternmatch is immediately followed by an unconditional \lstinline!branch! instruction,
which will jump to the \lstinline!ElseCode!, but is only reached if no match were found.

When a match is found, the execution jumps to the label indicating the start of the clause'body.
The opcodes of the clause'body are prefixed by instructions moving the capture
variables'values from their X register to their respectively assigned Y
registers.
The clause'body opcodes are immediately followed by an unconditional jump to
the label indicating the end of opcodes for the case instruction. This ensures
that no following clause' body is executed.

This is all there is for clauses with no guards. 

Guards, however, add some complexity to the generation of opcodes, and this is what we will look at now.
The augmented complexity comes first from the fact that a clauses with guards cannot
be grouped with other clauses. For each clause with guards, there will be a
test instruction generated. In addition, the code for the guards needs access
to the value of the captures in the pattern, meaning it must come after the
test instruction. A consequence of this is that the test instruction may not jump to the start
of the clause'body, but must jump to the guards'code!


\subsubsection{Instructions Sequences}
Generating opcodes for sequences of instructions consists in the generation in order of the opcodes for each element of the sequence. 
When \lstinline!CodeGen! visits a node \lstinline!fAnd(First Second)! in the AST, it first generates the opcodes for \lstinline!First!, then for \lstinline!Second!.


\section{Tests}
\subsection{Helper functions tests}
Some helper functions are tested specifically by Oz code, checking that the result returned by the function is correct. This is simply done by calling the function in Figure~\ref{fig:helperstestsfunction} with the first argument the function call we want to test, and the expected result as second argument as illustrated in Figure~\ref{fig:helperstestsexample} where the function UnWrapFAnd is tested.
The only downside to this approach is that helper functions have to be exported for them to be available in the test code..

\begin{figure}
\begin{lstlisting}
   proc {Equals Result Expected}
      if Result\=Expected then
         %Show error information
         raise unexpectedResult end
      end
      {System.printInfo '.'}
   end
\end{lstlisting}
\label{fig:helperstestsfunction}
\caption{HelpersTests function}
\end{figure}

\begin{figure}
\begin{lstlisting}
   {Equals 
      {Compile.unWrapFAnd fAnd(first fAnd(second third) )}
      first|second|third|nil }
\end{lstlisting}
\label{fig:helperstestsexample}
\caption{Helper test example}
\end{figure}
\subsection{Compiler tests}
Tests are defined by three files each:
\begin{itemize}
  \item the oz code to compile and execute
  \item the expected stdout
  \item the expected stderr
\end{itemize}
All these files are put under the tests/definitions directory.

A TestRunner script in oz loads the code found in the file whose path is passed as argument, parses it, gives the AST to the compiler which returns the opcodes which are assembled and executed. 
A shell script iterates over all tests and for each execute the TestRunner, puts the stdout and stderr in result files under the tests/results directory, compares their content with the expected results and in case of difference can open a diffviewer (like vimdiff).
All test code has a preamble comment describing what case this test covers.
If the test code contains the comment line
\begin{lstlisting}
%-- SKIP TEST-- 
\end{lstlisting}
the test is skipped. This was implemented to be able to run tests even if one of them was temporarily not passing.

Adding a test is very simple:
\begin{enumerate}
  \item put the code to compile and execute in an .oz file under tests/descriptions
  \item put the expected output in a file with same name but with extension .out
  \item put the expected error output in a file with same name but with extension .err
\end{enumerate}
Once this is done, the new test will be included in the next run.
It is also possible to run one individual test. In this case, the test is run even if it is maked as to be skipped when running the full test suite. This helps writing tests for cases needed to be supported in the future, but that should not make the full test suite fail.
\section{Performance}
Possibly include some measure?





\begin{appendices} 

  \chapter{Pattern Variables}\label{appendix:patternvariables}
%FIXME: arrange layout
Statements:
$
D1 D2                        PV(D1) \cup PV(D2)
x                            \{x\}
(S)                          PV(S)
(D in S)                     PV(S) - PV(D)
local D in S end             PV(S) - PV(D)
proc ... {E ...} ... end     PV(E)
fun ... {E ...} ... end      PV(E)
class E ... end              PV(E)
functor E ... end            PV(E)
E = ...                      PV(E)
otherwise                    \emptyset
$


Declarations:

$
x                                         \{x\}
(E)                                       PV(E)
(D in [ S ] E)                            (PV(S) \cup PV(E)) - PV(D)
local D in [ S ] E end                    (PV(S) \cup PV(E)) - PV(D)
E1 = E2                                   PV(E1) \cup PV(E2)
[E1 ... En]                               PV(E1) \cup ... \cup PV(En)
E1|E2                                     PV(E1) \cup PV(E2)
E1\#...\#En                                 PV(E1) \cup ... \cup PV(En)
il([ f1: ] E1 ... [ fn: ] En [ ... ])     PV(E1) \cup ... \cup PV(En)
otherwise                                 \emptyset
$

\chapter{Symbol Description}\label{appendix:symbol}
A symbol instance holds information about the variable it replaced in the AST. Symbols introduced by the compile are called synthetic symbols.
The attributes of the class are:
\begin{description}
  \item[id] A unique id for the symbol, used for debugging purposes.
  \item[name] The name of the variable it represents. This can be empty for symbols introduced by the compiler.
  \item[pos] The position of the variable's declaration in the source code.
  \item[xindex yindex gindex] The indexes of the registers assigned to the symbol. A symbol might have both a xindex and a yindex when it is a capture in a pattern. The xindex is the index in which the value of the capture is place, and the yindex is the index of the Y register assigned to the symbol for permanent storage in the clause'body.
  \item[procId] The procId in which this symbol is reachable.
  \item[type] The type of the symbol, which can take the following values:
    \begin{itemize}
      \item localProcId for a symbol corresponding to a variable defined in the procedure where it is located.
      \item localised for a symbol representing a global variable for the procId where it is located
      \item patternmatch for a symbol representing a capture in a pattern
      \item wildcard for a symbol introduced in the place of a wildcard
      \item ref is only used for localised symbols. It references a symbol local to the enclosing procedure, building a chain that will eventually lead to a symbol of type localProcId enabling the resolution of global variables. %FIXME: improve description..
    \end{itemize}
\end{description}

         ref
\end{appendices}
\end{document}

% vim: set textwidth=80
